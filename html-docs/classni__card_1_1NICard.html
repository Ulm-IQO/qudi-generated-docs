<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qudi: ni_card.NICard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qudi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ni_card</b></li><li class="navelem"><a class="el" href="classni__card_1_1NICard.html">NICard</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classni__card_1_1NICard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ni_card.NICard Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>stable Kay Jahnke, Alexander Stark  
 <a href="classni__card_1_1NICard.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ni_card.NICard:</div>
<div class="dyncontent">
<div class="center"><img src="classni__card_1_1NICard__inherit__graph.png" border="0" usemap="#ni__card_8NICard_inherit__map" alt="Inheritance graph"/></div>
<map name="ni__card_8NICard_inherit__map" id="ni__card_8NICard_inherit__map">
<area shape="rect" id="node11" href="classgated__ni__card_1_1SlowGatedNICard.html" title="Enable the usage of the gated counter in the slow counter interface. " alt="" coords="227,379,440,405"/>
<area shape="rect" id="node2" href="classcore_1_1module_1_1Base.html" title="core.module.Base" alt="" coords="17,229,143,256"/>
<area shape="rect" id="node6" href="classcore_1_1module_1_1ModuleMeta.html" title="Metaclass for Qudi modules. " alt="" coords="57,80,225,107"/>
<area shape="rect" id="node4" href="classcore_1_1module_1_1BaseMixin.html" title="Base class for all loadable modules. " alt="" coords="62,155,220,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ni_card.NICard:</div>
<div class="dyncontent">
<div class="center"><img src="classni__card_1_1NICard__coll__graph.png" border="0" usemap="#ni__card_8NICard_coll__map" alt="Collaboration graph"/></div>
<map name="ni__card_8NICard_coll__map" id="ni__card_8NICard_coll__map">
<area shape="rect" id="node2" href="classcore_1_1module_1_1Base.html" title="core.module.Base" alt="" coords="17,229,143,256"/>
<area shape="rect" id="node6" href="classcore_1_1module_1_1ModuleMeta.html" title="Metaclass for Qudi modules. " alt="" coords="57,80,225,107"/>
<area shape="rect" id="node4" href="classcore_1_1module_1_1BaseMixin.html" title="Base class for all loadable modules. " alt="" coords="62,155,220,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a856312a0a457f701189f00b028a67d95"><td class="memItemLeft" align="right" valign="top"><a id="a856312a0a457f701189f00b028a67d95"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a856312a0a457f701189f00b028a67d95">on_activate</a> (self)</td></tr>
<tr class="memdesc:a856312a0a457f701189f00b028a67d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts up the NI Card at activation. <br /></td></tr>
<tr class="separator:a856312a0a457f701189f00b028a67d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96b71eac83ec517f8a9e4cc01e27bf0"><td class="memItemLeft" align="right" valign="top"><a id="aa96b71eac83ec517f8a9e4cc01e27bf0"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#aa96b71eac83ec517f8a9e4cc01e27bf0">on_deactivate</a> (self)</td></tr>
<tr class="memdesc:aa96b71eac83ec517f8a9e4cc01e27bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the NI card. <br /></td></tr>
<tr class="separator:aa96b71eac83ec517f8a9e4cc01e27bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94351394f0e7a270787bc8fdc304eb6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a94351394f0e7a270787bc8fdc304eb6e">get_constraints</a> (self)</td></tr>
<tr class="memdesc:a94351394f0e7a270787bc8fdc304eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware limits of NI device.  <a href="#a94351394f0e7a270787bc8fdc304eb6e">More...</a><br /></td></tr>
<tr class="separator:a94351394f0e7a270787bc8fdc304eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e1697039257ef32c6324bd958942c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#aa4e1697039257ef32c6324bd958942c0">set_up_clock</a> (self, clock_frequency=None, clock_channel=None, scanner=False, idle=False)</td></tr>
<tr class="memdesc:aa4e1697039257ef32c6324bd958942c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the hardware clock of the NiDAQ card to give the timing.  <a href="#aa4e1697039257ef32c6324bd958942c0">More...</a><br /></td></tr>
<tr class="separator:aa4e1697039257ef32c6324bd958942c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc37611b383c9229731c689acb2ea6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ac3fc37611b383c9229731c689acb2ea6">set_up_counter</a> (self, counter_channels=None, sources=None, clock_channel=None, counter_buffer=None)</td></tr>
<tr class="memdesc:ac3fc37611b383c9229731c689acb2ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the actual counter with a given clock.  <a href="#ac3fc37611b383c9229731c689acb2ea6">More...</a><br /></td></tr>
<tr class="separator:ac3fc37611b383c9229731c689acb2ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f349fb7f6461c49bef0cf251371768a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a8f349fb7f6461c49bef0cf251371768a">get_counter_channels</a> (self)</td></tr>
<tr class="memdesc:a8f349fb7f6461c49bef0cf251371768a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of counter channel names.  <a href="#a8f349fb7f6461c49bef0cf251371768a">More...</a><br /></td></tr>
<tr class="separator:a8f349fb7f6461c49bef0cf251371768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789bd4425a4acb2c625df91a319dc11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a6789bd4425a4acb2c625df91a319dc11">get_counter</a> (self, samples=None)</td></tr>
<tr class="memdesc:a6789bd4425a4acb2c625df91a319dc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current counts per second of the counter.  <a href="#a6789bd4425a4acb2c625df91a319dc11">More...</a><br /></td></tr>
<tr class="separator:a6789bd4425a4acb2c625df91a319dc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489c1f4e1516f04c319d39247f507c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a7489c1f4e1516f04c319d39247f507c1">close_counter</a> (self, scanner=False)</td></tr>
<tr class="memdesc:a7489c1f4e1516f04c319d39247f507c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the counter or scanner and cleans up afterwards.  <a href="#a7489c1f4e1516f04c319d39247f507c1">More...</a><br /></td></tr>
<tr class="separator:a7489c1f4e1516f04c319d39247f507c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fbd314b886f771c0d58e6746a7bc48"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a30fbd314b886f771c0d58e6746a7bc48">close_clock</a> (self, scanner=False)</td></tr>
<tr class="memdesc:a30fbd314b886f771c0d58e6746a7bc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the clock and cleans up afterwards.  <a href="#a30fbd314b886f771c0d58e6746a7bc48">More...</a><br /></td></tr>
<tr class="separator:a30fbd314b886f771c0d58e6746a7bc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad424a77445bdea11026484c137ad89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a3ad424a77445bdea11026484c137ad89">reset_hardware</a> (self)</td></tr>
<tr class="memdesc:a3ad424a77445bdea11026484c137ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the NI hardware, so the connection is lost and other programs can access it.  <a href="#a3ad424a77445bdea11026484c137ad89">More...</a><br /></td></tr>
<tr class="separator:a3ad424a77445bdea11026484c137ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96472c58e0419946575aa379165d7e6"><td class="memItemLeft" align="right" valign="top"><a id="ad96472c58e0419946575aa379165d7e6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad96472c58e0419946575aa379165d7e6">get_scanner_axes</a> (self)</td></tr>
<tr class="memdesc:ad96472c58e0419946575aa379165d7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scanner axes depends on how many channels tha analog output task has. <br /></td></tr>
<tr class="separator:ad96472c58e0419946575aa379165d7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be8446ab426bc5645dd55416c5f14d9"><td class="memItemLeft" align="right" valign="top"><a id="a0be8446ab426bc5645dd55416c5f14d9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a0be8446ab426bc5645dd55416c5f14d9">get_scanner_count_channels</a> (self)</td></tr>
<tr class="memdesc:a0be8446ab426bc5645dd55416c5f14d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of counter channels. <br /></td></tr>
<tr class="separator:a0be8446ab426bc5645dd55416c5f14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5267dc97a7819a87e23395d626ae683"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#af5267dc97a7819a87e23395d626ae683">get_position_range</a> (self)</td></tr>
<tr class="memdesc:af5267dc97a7819a87e23395d626ae683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the physical range of the scanner.  <a href="#af5267dc97a7819a87e23395d626ae683">More...</a><br /></td></tr>
<tr class="separator:af5267dc97a7819a87e23395d626ae683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526922b67a75bb1a023a28b8b0dc3e2a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a526922b67a75bb1a023a28b8b0dc3e2a">set_position_range</a> (self, myrange=None)</td></tr>
<tr class="memdesc:a526922b67a75bb1a023a28b8b0dc3e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the physical range of the scanner.  <a href="#a526922b67a75bb1a023a28b8b0dc3e2a">More...</a><br /></td></tr>
<tr class="separator:a526922b67a75bb1a023a28b8b0dc3e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f1ffa246fac47565b6624b489ca0ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a86f1ffa246fac47565b6624b489ca0ba">set_voltage_range</a> (self, myrange=None)</td></tr>
<tr class="memdesc:a86f1ffa246fac47565b6624b489ca0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the voltage range of the NI Card.  <a href="#a86f1ffa246fac47565b6624b489ca0ba">More...</a><br /></td></tr>
<tr class="separator:a86f1ffa246fac47565b6624b489ca0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad588ef812b7f227eba9a356d1bd97ef6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad588ef812b7f227eba9a356d1bd97ef6">set_up_scanner_clock</a> (self, clock_frequency=None, clock_channel=None)</td></tr>
<tr class="memdesc:ad588ef812b7f227eba9a356d1bd97ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the hardware clock of the NiDAQ card to give the timing.  <a href="#ad588ef812b7f227eba9a356d1bd97ef6">More...</a><br /></td></tr>
<tr class="separator:ad588ef812b7f227eba9a356d1bd97ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816cadbc91ebe56757c85ec07fd44c1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a816cadbc91ebe56757c85ec07fd44c1c">set_up_scanner</a> (self, counter_channels=None, sources=None, clock_channel=None, scanner_ao_channels=None)</td></tr>
<tr class="memdesc:a816cadbc91ebe56757c85ec07fd44c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the actual scanner with a given clock.  <a href="#a816cadbc91ebe56757c85ec07fd44c1c">More...</a><br /></td></tr>
<tr class="separator:a816cadbc91ebe56757c85ec07fd44c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f68689c37ed37d9a1499720030c87d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a4f68689c37ed37d9a1499720030c87d8">scanner_set_position</a> (self, x=None, y=None, z=None, a=None)</td></tr>
<tr class="memdesc:a4f68689c37ed37d9a1499720030c87d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move stage to x, y, z, a (where a is the fourth voltage channel).  <a href="#a4f68689c37ed37d9a1499720030c87d8">More...</a><br /></td></tr>
<tr class="separator:a4f68689c37ed37d9a1499720030c87d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e69f8e8b6f8131b8faf37f77408d5b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a75e69f8e8b6f8131b8faf37f77408d5b">get_scanner_position</a> (self)</td></tr>
<tr class="memdesc:a75e69f8e8b6f8131b8faf37f77408d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current position of the scanner hardware.  <a href="#a75e69f8e8b6f8131b8faf37f77408d5b">More...</a><br /></td></tr>
<tr class="separator:a75e69f8e8b6f8131b8faf37f77408d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038f710dc436de0326b41efefc6acf44"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a038f710dc436de0326b41efefc6acf44">scan_line</a> (self, line_path=None, pixel_clock=False)</td></tr>
<tr class="memdesc:a038f710dc436de0326b41efefc6acf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans a line and return the counts on that line.  <a href="#a038f710dc436de0326b41efefc6acf44">More...</a><br /></td></tr>
<tr class="separator:a038f710dc436de0326b41efefc6acf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe2b8405fd455020ed0da8ace0980f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#adbe2b8405fd455020ed0da8ace0980f7">close_scanner</a> (self)</td></tr>
<tr class="memdesc:adbe2b8405fd455020ed0da8ace0980f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the scanner and cleans up afterwards.  <a href="#adbe2b8405fd455020ed0da8ace0980f7">More...</a><br /></td></tr>
<tr class="separator:adbe2b8405fd455020ed0da8ace0980f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a964bbf1d3f2ddd6726f0cd85ab0fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a52a964bbf1d3f2ddd6726f0cd85ab0fb">close_scanner_clock</a> (self)</td></tr>
<tr class="memdesc:a52a964bbf1d3f2ddd6726f0cd85ab0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the clock and cleans up afterwards.  <a href="#a52a964bbf1d3f2ddd6726f0cd85ab0fb">More...</a><br /></td></tr>
<tr class="separator:a52a964bbf1d3f2ddd6726f0cd85ab0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f12330aa92f2c7e4e0a3c95e702764"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a39f12330aa92f2c7e4e0a3c95e702764">set_up_odmr_clock</a> (self, clock_frequency=None, clock_channel=None)</td></tr>
<tr class="memdesc:a39f12330aa92f2c7e4e0a3c95e702764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the hardware clock of the NiDAQ card to give the timing.  <a href="#a39f12330aa92f2c7e4e0a3c95e702764">More...</a><br /></td></tr>
<tr class="separator:a39f12330aa92f2c7e4e0a3c95e702764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e1375b5aed38672390ca6ea36b63d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ab0e1375b5aed38672390ca6ea36b63d8">set_up_odmr</a> (self, counter_channel=None, photon_source=None, clock_channel=None, odmr_trigger_channel=None)</td></tr>
<tr class="memdesc:ab0e1375b5aed38672390ca6ea36b63d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the actual counter with a given clock.  <a href="#ab0e1375b5aed38672390ca6ea36b63d8">More...</a><br /></td></tr>
<tr class="separator:ab0e1375b5aed38672390ca6ea36b63d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ea0874c5f480cbae928ad067844bf5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a31ea0874c5f480cbae928ad067844bf5">set_odmr_length</a> (self, length=100)</td></tr>
<tr class="memdesc:a31ea0874c5f480cbae928ad067844bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the trigger sequence for the ODMR and the triggered microwave.  <a href="#a31ea0874c5f480cbae928ad067844bf5">More...</a><br /></td></tr>
<tr class="separator:a31ea0874c5f480cbae928ad067844bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3389d0ffc952031893cd55e52d110a97"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a3389d0ffc952031893cd55e52d110a97">count_odmr</a> (self, length=100)</td></tr>
<tr class="memdesc:a3389d0ffc952031893cd55e52d110a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sweeps the microwave and returns the counts on that sweep.  <a href="#a3389d0ffc952031893cd55e52d110a97">More...</a><br /></td></tr>
<tr class="separator:a3389d0ffc952031893cd55e52d110a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6765f3ec111dcc765cdac26cf1bf79b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#af6765f3ec111dcc765cdac26cf1bf79b">close_odmr</a> (self)</td></tr>
<tr class="memdesc:af6765f3ec111dcc765cdac26cf1bf79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the odmr and cleans up afterwards.  <a href="#af6765f3ec111dcc765cdac26cf1bf79b">More...</a><br /></td></tr>
<tr class="separator:af6765f3ec111dcc765cdac26cf1bf79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5530f85f593dc7ac6ade6b8f65daf08e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a5530f85f593dc7ac6ade6b8f65daf08e">close_odmr_clock</a> (self)</td></tr>
<tr class="memdesc:a5530f85f593dc7ac6ade6b8f65daf08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the odmr and cleans up afterwards.  <a href="#a5530f85f593dc7ac6ade6b8f65daf08e">More...</a><br /></td></tr>
<tr class="separator:a5530f85f593dc7ac6ade6b8f65daf08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313f64947f81d58fbc86691a78a54162"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a313f64947f81d58fbc86691a78a54162">get_status</a> (self)</td></tr>
<tr class="memdesc:a313f64947f81d58fbc86691a78a54162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the current status of the Fast Counter and outputs it as return value.  <a href="#a313f64947f81d58fbc86691a78a54162">More...</a><br /></td></tr>
<tr class="separator:a313f64947f81d58fbc86691a78a54162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621cb56e4adc8997deba3908eb785e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad621cb56e4adc8997deba3908eb785e2">set_up_gated_counter</a> (self, buffer_length, read_available_samples=False)</td></tr>
<tr class="memdesc:ad621cb56e4adc8997deba3908eb785e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and starts task for external gated photon counting.  <a href="#ad621cb56e4adc8997deba3908eb785e2">More...</a><br /></td></tr>
<tr class="separator:ad621cb56e4adc8997deba3908eb785e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcfaa68c2c22e133b7e88eec6aaef81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#abdcfaa68c2c22e133b7e88eec6aaef81">start_gated_counter</a> (self)</td></tr>
<tr class="memdesc:abdcfaa68c2c22e133b7e88eec6aaef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually start the preconfigured counter task.  <a href="#abdcfaa68c2c22e133b7e88eec6aaef81">More...</a><br /></td></tr>
<tr class="separator:abdcfaa68c2c22e133b7e88eec6aaef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412e89ef7d0a305937c31eaf5f0924d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a412e89ef7d0a305937c31eaf5f0924d2">get_gated_counts</a> (self, samples=None, timeout=None, read_available_samples=False)</td></tr>
<tr class="memdesc:a412e89ef7d0a305937c31eaf5f0924d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns latest count samples acquired by gated photon counting.  <a href="#a412e89ef7d0a305937c31eaf5f0924d2">More...</a><br /></td></tr>
<tr class="separator:a412e89ef7d0a305937c31eaf5f0924d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad020dd3cb95dd98cb2524f2f4369ba73"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad020dd3cb95dd98cb2524f2f4369ba73">stop_gated_counter</a> (self)</td></tr>
<tr class="memdesc:ad020dd3cb95dd98cb2524f2f4369ba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually start the preconfigured counter task.  <a href="#ad020dd3cb95dd98cb2524f2f4369ba73">More...</a><br /></td></tr>
<tr class="separator:ad020dd3cb95dd98cb2524f2f4369ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8ac2d05ff4c01cdd024a67d14cccdb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#aec8ac2d05ff4c01cdd024a67d14cccdb">close_gated_counter</a> (self)</td></tr>
<tr class="memdesc:aec8ac2d05ff4c01cdd024a67d14cccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear tasks, so that counters are not in use any more.  <a href="#aec8ac2d05ff4c01cdd024a67d14cccdb">More...</a><br /></td></tr>
<tr class="separator:aec8ac2d05ff4c01cdd024a67d14cccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5df4cf07a7f42b3f0fb82c45589387"><td class="memItemLeft" align="right" valign="top"><a id="a7f5df4cf07a7f42b3f0fb82c45589387"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>digital_channel_switch</b> (self, channel_name, mode=True)</td></tr>
<tr class="separator:a7f5df4cf07a7f42b3f0fb82c45589387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcore_1_1module_1_1BaseMixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcore_1_1module_1_1BaseMixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcore_1_1module_1_1BaseMixin.html">core.module.BaseMixin</a></td></tr>
<tr class="memitem:ad68ad62cea611ca8c4e6ba2efb259a3a inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#ad68ad62cea611ca8c4e6ba2efb259a3a">__init__</a> (self, manager, name, config=None, callbacks=None, kwargs)</td></tr>
<tr class="memdesc:ad68ad62cea611ca8c4e6ba2efb259a3a inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise <a class="el" href="classcore_1_1module_1_1Base.html">Base</a> class object and set up its state machine.  <a href="classcore_1_1module_1_1BaseMixin.html#ad68ad62cea611ca8c4e6ba2efb259a3a">More...</a><br /></td></tr>
<tr class="separator:ad68ad62cea611ca8c4e6ba2efb259a3a inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d688e252462b727566ddfaa8247d2d7 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top"><a id="a7d688e252462b727566ddfaa8247d2d7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#a7d688e252462b727566ddfaa8247d2d7">log</a> (self)</td></tr>
<tr class="memdesc:a7d688e252462b727566ddfaa8247d2d7 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logger object. <br /></td></tr>
<tr class="separator:a7d688e252462b727566ddfaa8247d2d7 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4fba8b730fde8892195e2f4b6d6c98 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top"><a id="a0e4fba8b730fde8892195e2f4b6d6c98"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#a0e4fba8b730fde8892195e2f4b6d6c98">is_module_threaded</a> (self)</td></tr>
<tr class="memdesc:a0e4fba8b730fde8892195e2f4b6d6c98 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the module shall be started in a thread. <br /></td></tr>
<tr class="separator:a0e4fba8b730fde8892195e2f4b6d6c98 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1126ae1cb8f0c13d22618da2fd8d61c inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#ad1126ae1cb8f0c13d22618da2fd8d61c">on_activate</a> (self)</td></tr>
<tr class="memdesc:ad1126ae1cb8f0c13d22618da2fd8d61c inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method called when module is activated.  <a href="classcore_1_1module_1_1BaseMixin.html#ad1126ae1cb8f0c13d22618da2fd8d61c">More...</a><br /></td></tr>
<tr class="separator:ad1126ae1cb8f0c13d22618da2fd8d61c inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa798764f84ec1971ba2c94c5b0a81781 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#aa798764f84ec1971ba2c94c5b0a81781">on_deactivate</a> (self)</td></tr>
<tr class="memdesc:aa798764f84ec1971ba2c94c5b0a81781 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method called when module is deactivated.  <a href="classcore_1_1module_1_1BaseMixin.html#aa798764f84ec1971ba2c94c5b0a81781">More...</a><br /></td></tr>
<tr class="separator:aa798764f84ec1971ba2c94c5b0a81781 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9c816e36860770b6f0d74a7fc411c0 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#a4a9c816e36860770b6f0d74a7fc411c0">getStatusVariables</a> (self)</td></tr>
<tr class="memdesc:a4a9c816e36860770b6f0d74a7fc411c0 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a dict of variable names and their content representing the module state for saving.  <a href="classcore_1_1module_1_1BaseMixin.html#a4a9c816e36860770b6f0d74a7fc411c0">More...</a><br /></td></tr>
<tr class="separator:a4a9c816e36860770b6f0d74a7fc411c0 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930ce24451be8938e1fe8521329b9265 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#a930ce24451be8938e1fe8521329b9265">setStatusVariables</a> (self, variableDict)</td></tr>
<tr class="memdesc:a930ce24451be8938e1fe8521329b9265 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a module a dict of variable names and their content representing the module state.  <a href="classcore_1_1module_1_1BaseMixin.html#a930ce24451be8938e1fe8521329b9265">More...</a><br /></td></tr>
<tr class="separator:a930ce24451be8938e1fe8521329b9265 inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd83da9a31c931a1e66b4527424feb4d inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#afd83da9a31c931a1e66b4527424feb4d">getConfiguration</a> (self)</td></tr>
<tr class="memdesc:afd83da9a31c931a1e66b4527424feb4d inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the configration dictionary for this module.  <a href="classcore_1_1module_1_1BaseMixin.html#afd83da9a31c931a1e66b4527424feb4d">More...</a><br /></td></tr>
<tr class="separator:afd83da9a31c931a1e66b4527424feb4d inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d83e01e4de86a01e3bf109c2072b3d inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1BaseMixin.html#ae4d83e01e4de86a01e3bf109c2072b3d">get_connector</a> (self, connector_name)</td></tr>
<tr class="memdesc:ae4d83e01e4de86a01e3bf109c2072b3d inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return module connected to the given named connector.  <a href="classcore_1_1module_1_1BaseMixin.html#ae4d83e01e4de86a01e3bf109c2072b3d">More...</a><br /></td></tr>
<tr class="separator:ae4d83e01e4de86a01e3bf109c2072b3d inherit pub_methods_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcore_1_1module_1_1ModuleMeta"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcore_1_1module_1_1ModuleMeta')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcore_1_1module_1_1ModuleMeta.html">core.module.ModuleMeta</a></td></tr>
<tr class="memitem:a7666bad96f55cd6770cb81698f186934 inherit pub_methods_classcore_1_1module_1_1ModuleMeta"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1module_1_1ModuleMeta.html#a7666bad96f55cd6770cb81698f186934">__new__</a> (mcs, name, bases, attrs)</td></tr>
<tr class="memdesc:a7666bad96f55cd6770cb81698f186934 inherit pub_methods_classcore_1_1module_1_1ModuleMeta"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect declared Connectors, ConfigOptions and StatusVars into dictionaries.  <a href="classcore_1_1module_1_1ModuleMeta.html#a7666bad96f55cd6770cb81698f186934">More...</a><br /></td></tr>
<tr class="separator:a7666bad96f55cd6770cb81698f186934 inherit pub_methods_classcore_1_1module_1_1ModuleMeta"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3071e7e2ffc48275acd2c95c70563ee7"><td class="memItemLeft" align="right" valign="top"><a id="a3071e7e2ffc48275acd2c95c70563ee7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>digital_out_task</b></td></tr>
<tr class="separator:a3071e7e2ffc48275acd2c95c70563ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6be70042d5763e88a56fbd8d4a94ee8"><td class="memItemLeft" align="right" valign="top"><a id="aa6be70042d5763e88a56fbd8d4a94ee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>digital_data</b></td></tr>
<tr class="separator:aa6be70042d5763e88a56fbd8d4a94ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f613c60aab19d58d55e43a6e5adb548"><td class="memItemLeft" align="right" valign="top"><a id="a1f613c60aab19d58d55e43a6e5adb548"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>digital_read</b></td></tr>
<tr class="separator:a1f613c60aab19d58d55e43a6e5adb548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33fa71ab29da7d4a9a724d19de0ebec"><td class="memItemLeft" align="right" valign="top"><a id="ac33fa71ab29da7d4a9a724d19de0ebec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>digital_samples_channel</b></td></tr>
<tr class="separator:ac33fa71ab29da7d4a9a724d19de0ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classcore_1_1module_1_1BaseMixin"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classcore_1_1module_1_1BaseMixin')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classcore_1_1module_1_1BaseMixin.html">core.module.BaseMixin</a></td></tr>
<tr class="memitem:ae798a19db540fd6b0f70f82750b99fba inherit pub_attribs_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top"><a id="ae798a19db540fd6b0f70f82750b99fba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>module_state</b></td></tr>
<tr class="separator:ae798a19db540fd6b0f70f82750b99fba inherit pub_attribs_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fc14182a8e42fc0804b848f4de3d24 inherit pub_attribs_classcore_1_1module_1_1BaseMixin"><td class="memItemLeft" align="right" valign="top"><a id="ab6fc14182a8e42fc0804b848f4de3d24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>connectors</b></td></tr>
<tr class="separator:ab6fc14182a8e42fc0804b848f4de3d24 inherit pub_attribs_classcore_1_1module_1_1BaseMixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>stable Kay Jahnke, Alexander Stark </p>
<p>A National Instruments device that can count and control microvave generators.</p>
<p>Basic procedure how the NI card is configurated:</p><ul>
<li>At first you have to define a channel, where the APD clicks will be received. That can be any PFI input, which is specified to record TTL pulses.</li>
<li>Then two counter channels have to be configured.</li>
<li>One counter channel serves as a timing device, i.e. basically a clock which runs at a certain given frequency.</li>
<li>The second counter channel will be used as a gated counting device, which will, dependent on the clock, count within the clock interval. The faster the clock channel is configured, the smaller is the gated counting interval and the less counts per clock periode you will count.</li>
</ul>
<p>Therefore the whole issue is to establish a time based gated-counting channel.</p>
<p>Text Based NI-DAQmx Data Acquisition Examples: <a href="http://www.ni.com/example/6999/en/#ANSIC">http://www.ni.com/example/6999/en/#ANSIC</a></p>
<p>Explanation of the termology, which is used in the NI Card and useful to know in connection with our implementation:</p>
<p>Hardware-Timed Counter Tasks: Use hardware-timed counter input operations to drive a control loop. A really good explanation can be found in:</p>
<p><a href="http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/controlappcase4/">http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/controlappcase4/</a></p>
<dl class="section user"><dt>Terminals</dt><dd>A terminal is a named location where a signal is either generated (output or produced) or acquired (input or consumed). A terminal that can output only one signal is often named after that signal. A terminal with an input that can be used only for one signal is often named after the clock or trigger that the signal is used for. Terminals that are used for many signals have generic names such as RTSI, PXITrig, or PFI. </dd></dl>
<dl class="section user"><dt></dt><dd><a href="http://zone.ni.com/reference/en-XX/help/370466W-01/mxcncpts/terminal/">http://zone.ni.com/reference/en-XX/help/370466W-01/mxcncpts/terminal/</a> <a href="http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/termnames/">http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/termnames/</a></dd></dl>
<p>Ctr0Out, Ctr1Out, Ctr2Out, Ctr3Out: Terminals at the I/O connector where the output of counter 0, counter 1, counter 2, or counter 3 can be emitted. You also can use Ctr0Out as a terminal for driving an external signal onto the RTSI bus.</p>
<p>Ctr0Gate, Ctr1Gate, Ctr2Gate, Ctr3Gate: Terminals within a device whose purpose depends on the application. Refer to Counter Parts in NI-DAQmx for more information on how the gate terminal is used in various applications.</p>
<p>Ctr0Source, Ctr1Source, Ctr2Source, Ctr3Source: Terminals within a device whose purpose depends on the application. Refer to Counter Parts in NI-DAQmx for more information on how the source terminal is used in various applications.</p>
<p>Ctr0InternalOutput, Ctr1InternalOutput, Ctr2InternalOutput, </p><dl class="section user"><dt>Ctr3InternalOutput</dt><dd>Terminals within a device where you can choose the pulsed or toggled output of the counters. Refer to Counter Parts in NI-DAQmx (or MAX) for more information on internal output terminals.</dd></dl>
<p>Task State Model: NI-DAQmx uses a task state model to improve ease of use and speed up driver performance. Have a look at</p>
<p><a href="http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/taskstatemodel/">http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/taskstatemodel/</a></p>
<p>Small The task state model consists of five states</p><ol type="1">
<li>Unverified,</li>
<li>Verified,</li>
<li>Reserved,</li>
<li>Committed,</li>
<li>Running. You call the Start Task function/VI, Stop Task function/VI, and Control Task function/VI to transition the task from one state to another. The task state model is very flexible. You can choose to interact with as little or as much of the task state model as your application requires.</li>
</ol>
<p>Device limitations: Keep in mind that ONLY the X-series of the NI cards is capable of doing a Counter Output Pulse Frequency Train with finite numbers of samples by using ONE internal device channel clock (that is the function DAQmxCreateCOPulseChanFreq or CO Pulse Freq in Labview)! All other card series have to use two counters to generate that! Check out the description of NI which tells you 'How Many Counters Does Each Type of Counter Input or Output Task Take':</p>
<p><a href="http://digital.ni.com/public.nsf/allkb/9D1780F448D10F4686257590007B15A8">http://digital.ni.com/public.nsf/allkb/9D1780F448D10F4686257590007B15A8</a></p>
<p>This code was tested with NI 6323 and NI 6229, where the first one is an X-series device and the latter one is a Low-Cost M Series device. With the NI 6229 it is not possible at all to perform the scanning task unless you have two of that cards. The limitation came from a lack of internal counters. The NI 6323 was taken as a basis for this hardware module and thus all the function are working on that card. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a30fbd314b886f771c0d58e6746a7bc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fbd314b886f771c0d58e6746a7bc48">&#9670;&nbsp;</a></span>close_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the clock and cleans up afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bool</td><td>scanner: specifies if the counter- or scanner- function should be used to close the device. True = scanner False = counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a7489c1f4e1516f04c319d39247f507c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7489c1f4e1516f04c319d39247f507c1">&#9670;&nbsp;</a></span>close_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the counter or scanner and cleans up afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bool</td><td>scanner: specifies if the counter- or scanner- function will be excecuted to close the device. True = scanner False = counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="aec8ac2d05ff4c01cdd024a67d14cccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8ac2d05ff4c01cdd024a67d14cccdb">&#9670;&nbsp;</a></span>close_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear tasks, so that counters are not in use any more. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="af6765f3ec111dcc765cdac26cf1bf79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6765f3ec111dcc765cdac26cf1bf79b">&#9670;&nbsp;</a></span>close_odmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_odmr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the odmr and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a5530f85f593dc7ac6ade6b8f65daf08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5530f85f593dc7ac6ade6b8f65daf08e">&#9670;&nbsp;</a></span>close_odmr_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_odmr_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the odmr and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="adbe2b8405fd455020ed0da8ace0980f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe2b8405fd455020ed0da8ace0980f7">&#9670;&nbsp;</a></span>close_scanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_scanner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the scanner and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a52a964bbf1d3f2ddd6726f0cd85ab0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a964bbf1d3f2ddd6726f0cd85ab0fb">&#9670;&nbsp;</a></span>close_scanner_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_scanner_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the clock and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a3389d0ffc952031893cd55e52d110a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3389d0ffc952031893cd55e52d110a97">&#9670;&nbsp;</a></span>count_odmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.count_odmr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sweeps the microwave and returns the counts on that sweep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>length: length of microwave sweep in pixel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float[]: the photon counts per second </dd></dl>

</div>
</div>
<a id="a94351394f0e7a270787bc8fdc304eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94351394f0e7a270787bc8fdc304eb6e">&#9670;&nbsp;</a></span>get_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hardware limits of NI device. </p>
<dl class="section return"><dt>Returns</dt><dd>SlowCounterConstraints: constraints class for slow counter</dd></dl>
<p>FIXME ask hardware for limits when module is loaded </p>

</div>
</div>
<a id="a6789bd4425a4acb2c625df91a319dc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789bd4425a4acb2c625df91a319dc11">&#9670;&nbsp;</a></span>get_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current counts per second of the counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>samples: if defined, number of samples to read in one go. How many samples are read per readout cycle. The readout frequency was defined in the counter setup. That sets also the length of the readout array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float [samples]: array with entries as photon counts per second </dd></dl>

</div>
</div>
<a id="a8f349fb7f6461c49bef0cf251371768a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f349fb7f6461c49bef0cf251371768a">&#9670;&nbsp;</a></span>get_counter_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_counter_channels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of counter channel names. </p>
<dl class="section return"><dt>Returns</dt><dd>tuple(str): channel names</dd></dl>
<p>Most methods calling this might just care about the number of channels, though. </p>

</div>
</div>
<a id="a412e89ef7d0a305937c31eaf5f0924d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412e89ef7d0a305937c31eaf5f0924d2">&#9670;&nbsp;</a></span>get_gated_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_gated_counts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_available_samples</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns latest count samples acquired by gated photon counting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>samples: if defined, number of samples to read in one go. How many samples are read per readout cycle. The readout frequency was defined in the counter setup. That sets also the length of the readout array. </td></tr>
    <tr><td class="paramname">int</td><td>timeout: Maximal timeout for the read process. Since nidaq waits for all samples to be acquired, make sure this is long enough. </td></tr>
    <tr><td class="paramname">bool</td><td>read_available_samples : if False, NiDaq waits for the sample you asked for to be in the buffer before, True it returns what is in buffer until 'samples' is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5267dc97a7819a87e23395d626ae683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5267dc97a7819a87e23395d626ae683">&#9670;&nbsp;</a></span>get_position_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_position_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the physical range of the scanner. </p>
<dl class="section return"><dt>Returns</dt><dd>float [4][2]: array of 4 ranges with an array containing lower and upper limit. The unit of the scan range is meters. </dd></dl>

</div>
</div>
<a id="a75e69f8e8b6f8131b8faf37f77408d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e69f8e8b6f8131b8faf37f77408d5b">&#9670;&nbsp;</a></span>get_scanner_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_scanner_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current position of the scanner hardware. </p>
<dl class="section return"><dt>Returns</dt><dd>float[]: current position in (x, y, z, a). </dd></dl>

</div>
</div>
<a id="a313f64947f81d58fbc86691a78a54162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313f64947f81d58fbc86691a78a54162">&#9670;&nbsp;</a></span>get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_status </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the current status of the Fast Counter and outputs it as return value. </p>
<p>0 = unconfigured 1 = idle 2 = running 3 = paused -1 = error state </p>

</div>
</div>
<a id="a3ad424a77445bdea11026484c137ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad424a77445bdea11026484c137ad89">&#9670;&nbsp;</a></span>reset_hardware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.reset_hardware </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the NI hardware, so the connection is lost and other programs can access it. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a038f710dc436de0326b41efefc6acf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038f710dc436de0326b41efefc6acf44">&#9670;&nbsp;</a></span>scan_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.scan_line </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>line_path</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pixel_clock</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans a line and return the counts on that line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float[c][m]</td><td>line_path: array of c-tuples defining the voltage points (m = samples per line) </td></tr>
    <tr><td class="paramname">bool</td><td>pixel_clock: whether we need to output a pixel clock for this line</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float[m][n]: m (samples per line) n-channel photon counts per second</dd></dl>
<p>The input array looks for a xy scan of 5x5 points at the position z=-2 like the following: [ [1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [-2, -2, -2, -2] ] n is the number of scanner axes, which can vary. Typical values are 2 for galvo scanners, 3 for xyz scanners and 4 for xyz scanners with a special function on the a axis. </p>

</div>
</div>
<a id="a4f68689c37ed37d9a1499720030c87d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f68689c37ed37d9a1499720030c87d8">&#9670;&nbsp;</a></span>scanner_set_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.scanner_set_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move stage to x, y, z, a (where a is the fourth voltage channel). </p>
<p>#FIXME: No volts </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>x: postion in x-direction (volts) </td></tr>
    <tr><td class="paramname">float</td><td>y: postion in y-direction (volts) </td></tr>
    <tr><td class="paramname">float</td><td>z: postion in z-direction (volts) </td></tr>
    <tr><td class="paramname">float</td><td>a: postion in a-direction (volts)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a31ea0874c5f480cbae928ad067844bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ea0874c5f480cbae928ad067844bf5">&#9670;&nbsp;</a></span>set_odmr_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_odmr_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the trigger sequence for the ODMR and the triggered microwave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>length: length of microwave sweep in pixel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a526922b67a75bb1a023a28b8b0dc3e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526922b67a75bb1a023a28b8b0dc3e2a">&#9670;&nbsp;</a></span>set_position_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_position_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>myrange</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the physical range of the scanner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>[4][2] myrange: array of 4 ranges with an array containing lower and upper limit. The unit of the scan range is meters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="aa4e1697039257ef32c6324bd958942c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e1697039257ef32c6324bd958942c0">&#9670;&nbsp;</a></span>set_up_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_frequency</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idle</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the hardware clock of the NiDAQ card to give the timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>clock_frequency: if defined, this sets the frequency of the clock in Hz </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this is the physical channel of the clock within the NI card. </td></tr>
    <tr><td class="paramname">bool</td><td>scanner: if set to True method will set up a clock function for the scanner, otherwise a clock function for a counter will be set. </td></tr>
    <tr><td class="paramname">bool</td><td>idle: set whether idle situation of the counter (where counter is doing nothing) is defined as True = 'Voltage High/Rising Edge' False = 'Voltage Low/Falling Edge'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ac3fc37611b383c9229731c689acb2ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fc37611b383c9229731c689acb2ea6">&#9670;&nbsp;</a></span>set_up_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_channels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_buffer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the actual counter with a given clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list(str)</td><td>counter_channels: optional, physical channel of the counter </td></tr>
    <tr><td class="paramname">list(str)</td><td>sources: optional, physical channel where the photons are to count from </td></tr>
    <tr><td class="paramname">str</td><td>clock_channel: optional, specifies the clock channel for the counter </td></tr>
    <tr><td class="paramname">int</td><td>counter_buffer: optional, a buffer of specified integer length, where in each bin the count numbers are saved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ad621cb56e4adc8997deba3908eb785e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad621cb56e4adc8997deba3908eb785e2">&#9670;&nbsp;</a></span>set_up_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_available_samples</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and starts task for external gated photon counting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>buffer_length: Defines how long the buffer to be filled with samples should be. If buffer is full, program crashes, so use upper bound. Some reference calculated with sample_rate (in Samples/second) divided by Buffer_size: sample_rate/Buffer_size = no rate / 10kS, (0-100S/s) / 10kS (101-10kS/s)/ 1kS, (10k-1MS/s) / 100kS, (&gt;1MS/s) / 1Ms </td></tr>
    <tr><td class="paramname">bool</td><td>read_available_samples: if False, NiDaq waits for the sample you asked for to be in the buffer before, if True it returns what is in buffer until 'samples' is full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0e1375b5aed38672390ca6ea36b63d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e1375b5aed38672390ca6ea36b63d8">&#9670;&nbsp;</a></span>set_up_odmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_odmr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>photon_source</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>odmr_trigger_channel</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the actual counter with a given clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>counter_channel: if defined, this is the physical channel of the counter </td></tr>
    <tr><td class="paramname">string</td><td>photon_source: if defined, this is the physical channel where the photons are to count from </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this specifies the clock for the counter </td></tr>
    <tr><td class="paramname">string</td><td>odmr_trigger_channel: if defined, this specifies the trigger output for the microwave</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a39f12330aa92f2c7e4e0a3c95e702764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f12330aa92f2c7e4e0a3c95e702764">&#9670;&nbsp;</a></span>set_up_odmr_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_odmr_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_frequency</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the hardware clock of the NiDAQ card to give the timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>clock_frequency: if defined, this sets the frequency of the clock </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this is the physical channel of the clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a816cadbc91ebe56757c85ec07fd44c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816cadbc91ebe56757c85ec07fd44c1c">&#9670;&nbsp;</a></span>set_up_scanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_scanner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_channels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner_ao_channels</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the actual scanner with a given clock. </p>
<p>The scanner works pretty much like the counter. Here you connect a created clock with a counting task. That can be seen as a gated counting, where the counts where sampled by the underlying clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list(str)</td><td>counter_channels: this is the physical channel of the counter </td></tr>
    <tr><td class="paramname">list(str)</td><td>sources: this is the physical channel where the photons are to count from </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: optional, if defined, this specifies the clock for the counter </td></tr>
    <tr><td class="paramname">list(str)</td><td>scanner_ao_channels: optional, if defined, this specifies the analog output channels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ad588ef812b7f227eba9a356d1bd97ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad588ef812b7f227eba9a356d1bd97ef6">&#9670;&nbsp;</a></span>set_up_scanner_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_scanner_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_frequency</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the hardware clock of the NiDAQ card to give the timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>clock_frequency: if defined, this sets the frequency of the clock </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this is the physical channel of the clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a86f1ffa246fac47565b6624b489ca0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f1ffa246fac47565b6624b489ca0ba">&#9670;&nbsp;</a></span>set_voltage_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_voltage_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>myrange</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the voltage range of the NI Card. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>[n][2] myrange: array containing lower and upper limit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="abdcfaa68c2c22e133b7e88eec6aaef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcfaa68c2c22e133b7e88eec6aaef81">&#9670;&nbsp;</a></span>start_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.start_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually start the preconfigured counter task. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ad020dd3cb95dd98cb2524f2f4369ba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad020dd3cb95dd98cb2524f2f4369ba73">&#9670;&nbsp;</a></span>stop_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.stop_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually start the preconfigured counter task. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hardware/ni_card.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
